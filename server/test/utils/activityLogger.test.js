// test/activitylogger.test.js
let chai;
let expect;

before(async () => {
  chai = await import("chai");
  expect = chai.expect;
});
const sinon = require("sinon");
const proxyquire = require("proxyquire");
const ActivityLog = require("../../models/ActivityLog");
const mongoose = require("mongoose");

describe("Activity Logger", () => {
  let logActivity;
  let saveStub;
  let consoleErrorStub;

  beforeEach(() => {
    // Stub the save method of the ActivityLog model
    saveStub = sinon.stub(ActivityLog.prototype, "save");

    // Stub console.error to prevent actual console output during tests
    consoleErrorStub = sinon.stub(console, "error");

    // Use proxyquire to inject the stubbed model
    logActivity = proxyquire("../../utils/activityLogger", {
      "../models/ActivityLog": ActivityLog,
    }).logActivity;
  });

  afterEach(() => {
    sinon.restore(); // Restore all stubs after each test
  });

  it("should successfully log an activity", async () => {
    const userId = new mongoose.Types.ObjectId();
    const type = "upload";
    const text = "Uploaded a document";
    const documentId = new mongoose.Types.ObjectId();
    const options = { documentId: documentId };

    const expectedLog = {
      userId,
      type,
      text,
      documentId,
      textId: undefined,
      metadata: undefined,
      _id: new mongoose.Types.ObjectId(), // Mock an _id since it's usually generated by MongoDB
    };

    // Set up the stub to resolve with a mock activity log
    saveStub.resolves(expectedLog); // Resolve with the simplified object

    const result = await logActivity(userId, type, text, options);
    expect(result.type).to.be.equal(type);
    expect(result.text).to.be.equal(text);
    expect(result.userId).to.be.equal(userId);
    expect(result.documentId).to.be.equal(documentId);
    expect(saveStub.calledOnce).to.be.true;
  });

  it("should handle errors during activity logging", async () => {
    const userId = new mongoose.Types.ObjectId();
    const type = "upload";
    const text = "Uploaded a document";

    // Set up the save stub to reject with an error
    saveStub.rejects(new Error("Database error"));

    const result = await logActivity(userId.toString(), type, text); //Pass user id string

    expect(result).to.be.null;
    expect(saveStub.calledOnce).to.be.true;
    expect(consoleErrorStub.calledOnce).to.be.true;
    expect(consoleErrorStub.args[0][0]).to.equal("Error logging activity:");
    expect(consoleErrorStub.args[0][1].message).to.equal("Database error");
  });

  it("should log an activity with minimal data", async () => {
    const userId = new mongoose.Types.ObjectId();
    const type = "login";
    const text = "User logged in";

    const expectedLog = {
      userId,
      type,
      text,
      documentId: undefined,
      textId: undefined,
      metadata: undefined,
      _id: new mongoose.Types.ObjectId(), // Mock _id
    };

    saveStub.resolves(expectedLog); // Resolve with simplified object

    const result = await logActivity(userId.toString(), type, text); //pass userId as string
    expect(result.type).to.be.equal(type);
    expect(result.text).to.be.equal(text);
    expect(saveStub.calledOnce).to.be.true;
  });

  it("should log an activity with all optional data", async () => {
    const userId = new mongoose.Types.ObjectId();
    const type = "share";
    const text = "Shared a text snippet";
    const documentId = new mongoose.Types.ObjectId();
    const textId = new mongoose.Types.ObjectId();
    const options = {
      documentId: documentId,
      textId: textId,
      metadata: { someKey: "someValue" },
    };

    const expectedLog = {
      userId,
      type,
      text,
      documentId,
      textId,
      metadata: options.metadata,
      _id: new mongoose.Types.ObjectId(), // Mock _id
    };
    saveStub.resolves(expectedLog); // Resolve with simplified object
    const result = await logActivity(userId.toString(), type, text, options); //pass userId as string
    expect(result.type).to.be.equal(type);
    expect(result.text).to.be.equal(text);
    expect(result.documentId).to.be.equal(documentId);
    expect(saveStub.calledOnce).to.be.true;
  });
});
